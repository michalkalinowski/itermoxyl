#!/usr/bin/env python3

import argparse
import re
import signal
import subprocess
import sys
import glob
import os
from math import ceil
from os.path import expanduser, normpath, join

VERSION_MAJOR = 1
VERSION_MINOR = 3
VERSION_PATCH = 0

CONFIG_PATH = expanduser("~/.ssh/")

home = expanduser("~")
# this regexp will extract a integer suffix, if ones exists, then use
# the prefix as first sorting field and the suffix and the second one
host_split = re.compile(r"(\D+(?:\d+\D+)*)(\d+)")

parser = argparse.ArgumentParser(
    description=(
        "Tool to open multiple SSH connections in iTerm2. Use `--find` to search ~/.ssh/config by regex, or `--list` to specify hosts directly."
    )
)
mode_group = parser.add_mutually_exclusive_group(required=False)
mode_group.add_argument(
    "-f", "--find", dest="mode", action="store_const", const="find",
    help="Search hosts from ssh config using regex patterns"
)
mode_group.add_argument(
    "-l", "--list", dest="mode", action="store_const", const="list",
    help="Use the following hosts or IPs directly"
)
parser.add_argument(
    "-r", "--run", dest="should_actually_run", action="store_true", default=False,
    help="Skip confirmation and immediately open panes"
)
parser.add_argument(
    "-d", "--debug", action="store_true", default=False,
    help="Dump the generated AppleScript and exit"
)
parser.add_argument(
    "-v", "--version", action="store_true", default=False,
    help="Print version and exit"
)
parser.add_argument(
    "hosts", nargs="*", help="Regex patterns (in find mode) or explicit hosts/IPs (in list mode)"
)
arguments = parser.parse_args()


# noinspection PyUnusedLocal
def signal_handler(sig, frame):
    # Gracefully exit if Ctrl+C is pressed
    sys.exit(0)

if arguments.version:
    print("{}.{}.{}".format(VERSION_MAJOR, VERSION_MINOR, VERSION_PATCH))
    sys.exit(0)

if not arguments.mode:
    parser.error("One of --find/-f or --list/-l is required (unless using --version)")


def load_known_hosts(known_hosts_file='known_hosts'):
    path = normpath(join(CONFIG_PATH, known_hosts_file))
    hosts = set()
    try:
        with open(path) as f:
            for line in f:
                line = line.strip()
                if not line or line.startswith('#'):
                    continue
                host_field = line.split()[0]
                for h in host_field.split(','):
                    if h.startswith('|'):
                        continue
                    if h.startswith('[') and ']' in h:
                        h = h[1:h.index(']')]
                    hosts.add(h)
    except FileNotFoundError:
        pass
    return hosts


def load_ssh_config(config_file='config'):
    path = normpath(join(CONFIG_PATH, config_file))
    hosts = set()
    try:
        with open(path) as f:
            for line in f:
                line = line.strip()
                if not line or line.startswith('#'):
                    continue
                parts = line.split()
                if parts[0].lower() == 'host' and len(parts) > 1:
                    for h in parts[1:]:
                        if any(c in h for c in ['*', '?', '[', ']']):
                            continue
                        hosts.add(h)
    except FileNotFoundError:
        pass
    return hosts


def load_hosts():
    known = load_known_hosts()
    config = load_ssh_config()
    combined = known.union(config)
    if not combined:
        print("No hosts found in {}known_hosts or {}config".format(CONFIG_PATH, CONFIG_PATH))
        sys.exit(1)
    return combined


def check_if_iterm_version_is_supported():
    osa = subprocess.Popen(['osascript', '-'],
                           stdin=subprocess.PIPE,
                           stdout=subprocess.PIPE,
                           universal_newlines=True)

    version_script = 'set iterm_version to (get version of application "iTerm")'
    version = str(osa.communicate(version_script)[0]).strip()

    match = re.search(r"^(\d+)\.(\d+)", version)
    if match:
        major = int(match.group(1))
        minor = int(match.group(2))
        return (major > 2) or (major == 2 and minor > 9)  # support only if greater than 2.9
    return False


def prompt_for_confirmation(hosts_count):
    print("\nNumber of panes to open: {}".format(hosts_count))
    sys.stdout.write("Press 'y' to continue (or any other key to abort): ")
    choice = input().strip().lower()
    return choice == "y"


def create_pane(parent, child, orientation):
    return """
        tell pane_{parent}
            set pane_{child} to (split {orientation}ly with same profile)
        end tell
        """.format(parent=parent, child=child, orientation=orientation)


def init_pane(number, host):
    return """
        tell pane_{number}
            write text "ssh {host}"
            set name to "{host}"
        end tell
        """.format(number=number, host=host)


def prepare_and_run_applescript(selected_hosts):
    num_panes = len(selected_hosts)
    vertical_splits = int(ceil((num_panes / 2.0))) - 1
    second_columns = num_panes // 2
    pane_creation = ""

    for p in range(0, vertical_splits):
        parent = (p * 2) + 1
        child = parent + 2
        pane_creation += create_pane(parent, child, "horizontal")

    for p in range(0, second_columns):
        parent = (p * 2) + 1
        child = parent + 1
        pane_creation += create_pane(parent, child, "vertical")

    pane_initialization = ""

    for i in range(0, num_panes):
        pane_initialization += init_pane(i + 1, selected_hosts[i])

    script = """
        tell application "iTerm"
            activate
            tell current window
                create tab with default profile
            end tell

            set pane_1 to (current session of current window)

            {pane_creation}
            {pane_initialization}
        end tell
        """.format(pane_creation=pane_creation, pane_initialization=pane_initialization)

    if arguments.debug:
        print(script)
        sys.exit(0)

    osa = subprocess.Popen(['osascript', '-'],
                           stdin=subprocess.PIPE,
                           stdout=subprocess.PIPE,
                           universal_newlines=True)
    output = osa.communicate(script)[0]
    print(output)


def split_host_by_prefix_and_suffix(host):
    """ This is a hack to get hosts correctly ordered by number. When ordering, we'd expect "foo1, foo2, ... foo10", but
        when we order lexicographically, we get "foo1, foo10, foo2, ...". So this method splits the common prefix apart
        from the number suffix (in case there is one), then order first by the prefix and if there's a draw, order by
        suffix.
    """
    result = host_split.match(host)
    if result:
        prefix = result.group(1)
        suffix = int(result.group(2)) if result.group(2) else 0
    else:
        prefix = host
        suffix = 0
    return prefix, suffix


def sort_hosts(selected_hosts):
    return sorted(selected_hosts, key=lambda host: split_host_by_prefix_and_suffix(host))


def main():
    if not check_if_iterm_version_is_supported():
        print("iTerm2 version not supported or not installed")
        sys.exit(1)

    if arguments.mode == 'list':
        if not arguments.hosts:
            print("No hosts provided for --list mode.")
            sys.exit(1)
        selected_hosts = arguments.hosts
    else:  # find mode
        if not arguments.hosts:
            parser.error("At least one regex pattern is required for --find mode.")

        loose_search = ".*?".join(["(?:{})".format(p) for p in arguments.hosts])
        pat = re.compile(loose_search, re.IGNORECASE)
        available_hosts = load_hosts()

        selected_hosts = list(host for host in available_hosts if pat.search(host))

        if len(selected_hosts) == 0:
            print("There are no hosts that match the given filter.")
            sys.exit(0)

        selected_hosts = sort_hosts(selected_hosts)

    print("Will open the following terminal panes:\n")
    for host in selected_hosts:
        print("- {}".format(host))

    if arguments.should_actually_run or prompt_for_confirmation(len(selected_hosts)):
        prepare_and_run_applescript(selected_hosts)


if __name__ == '__main__':
    signal.signal(signal.SIGINT, signal_handler)
    main()